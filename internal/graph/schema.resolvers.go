package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"time"

	"go-training-system/internal/graph/apperror"
	"go-training-system/internal/graph/helper"
	"go-training-system/internal/graph/model"
	"go-training-system/pkg/jwt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.UserMutationResponse, error) {
	user, err := r.UserService.Register(ctx, &input)
	if err != nil {
		if err == apperror.ErrEmailTaken {
			msg := err.Error()
			return helper.NewUserMutationError("400", &msg, nil), nil
		}
		msg := err.Error()
		return helper.NewUserMutationError("500", &msg, nil), nil
	}

	if user == nil {
		msg := "Failed to create user"
		return helper.NewUserMutationError("500", &msg, nil), nil
	}

	createdAtStr := user.CreatedAt.Format(time.RFC3339)
	gqlUser := &model.User{
		UserID:    user.ID.String(),
		Username:  user.Username,
		Email:     user.Email,
		Role:      model.UserType(user.Role),
		CreatedAt: &createdAtStr,
	}

	return helper.NewUserMutationSuccess(gqlUser), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, input model.UpdateUserInput) (*model.UserMutationResponse, error) {
	panic(fmt.Errorf("not implemented: UpdateUser - updateUser"))
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.UserInput) (*model.AuthMutationResponse, error) {
	foundUser, err := r.UserService.Login(ctx, &input)
	if err != nil {
		if err == apperror.ErrInvalidLogin {
			msg := err.Error()
			return helper.AuthMutationError("401", msg, nil), nil
		}
		msg := "Internal server error"
		return helper.AuthMutationError("500", msg, nil), nil
	}
	if foundUser == nil {
		msg := "User not found"
		return helper.AuthMutationError("404", msg, nil), nil
	}

	accessToken, err := jwt.GenerateJWT(foundUser.ID.String(), string(foundUser.Role), r.JWTSecret, time.Hour*24)
	if err != nil {
		msg := "Failed to generate access token"
		return helper.AuthMutationError("500", msg, nil), nil
	}

	refreshToken, err := jwt.GenerateJWT(foundUser.ID.String(), string(foundUser.Role), r.JWTSecret, time.Hour*24*30)
	if err != nil {
		msg := "Failed to generate refresh token"
		return helper.AuthMutationError("500", msg, nil), nil
	}

	createdAtStr := foundUser.CreatedAt.Format(time.RFC3339)
	gqlUser := &model.User{
		UserID:    foundUser.ID.String(),
		Username:  foundUser.Username,
		Email:     foundUser.Email,
		Role:      model.UserType(foundUser.Role),
		CreatedAt: &createdAtStr,
	}
	// You should return a valid AuthMutationResponse here, for example:
	return helper.AuthMutationSuccess(accessToken, refreshToken, gqlUser), nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	panic(fmt.Errorf("not implemented: Logout - logout"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, role *model.UserType) ([]*model.User, error) {
	userID, ok := ctx.Value("user_id").(string)
	if !ok || userID == "" {
		return nil, apperror.ErrUnauthorized
	}

	users, err := r.UserService.GetAll(ctx, role)
	if err != nil {
		return nil, err
	}
	result := make([]*model.User, 0, len(users))
	for _, user := range users {
		createdAt := user.CreatedAt.Format(time.RFC3339)
		result = append(result, &model.User{
			UserID:    user.ID.String(),
			Username:  user.Username,
			Email:     user.Email,
			Role:      model.UserType(user.Role),
			CreatedAt: &createdAt,
		})
	}
	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, userID *string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Teams is the resolver for the teams field.
func (r *queryResolver) Teams(ctx context.Context) ([]*model.Team, error) {
	panic(fmt.Errorf("not implemented: Teams - teams"))
}

// Team is the resolver for the team field.
func (r *queryResolver) Team(ctx context.Context, teamID string) (*model.Team, error) {
	panic(fmt.Errorf("not implemented: Team - team"))
}

// MyTeams is the resolver for the myTeams field.
func (r *queryResolver) MyTeams(ctx context.Context) ([]*model.Team, error) {
	panic(fmt.Errorf("not implemented: MyTeams - myTeams"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	panic(fmt.Errorf("not implemented: CreateTodo - createTodo"))
}
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}
*/
